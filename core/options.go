package core

import (
	"bufio"
	"errors"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strconv"
	"strings"

	"github.com/goccy/go-yaml"
	flags "github.com/spf13/pflag"
)

var version = "1.1.5"

type Options struct {
	RestartRimeCmd string   `yaml:"restart_rime_cmd"`
	UserPath       string   `yaml:"user_path"`
	DictPaths      []string `yaml:"dict_paths"`
	SyncOnChange   bool     `yaml:"sync_on_change"`
	Export         string   `yaml:"export"`
	ExportColumns  string   `yaml:"export_columns"`
}

func ParseOptions() (Options, string) {
	configDir, _ := os.UserConfigDir()
	defaultConfigPath := filepath.Join(configDir, "rimedm", "config.yaml")

	configPath := flags.StringP("config", "c", defaultConfigPath, "配置文件路径，若不指定，将从默认路径读取配置")

	dictPaths := flags.StringArrayP("dict", "d", []string{}, "(当使用配置文件时可选)主词典文件(方案名.dict.yaml)路径，通过主词典会自动加载其他拓展词典，无需指定拓展词典。\n支持多个主词典文件，\ne.g: rimedm -d ./xkjd6.dict.yaml -d ./xhup.dict.txt")

	userPath := flags.StringP("user", "u", "", "用户词典路径，此选项的作用是在加词时默认首选")

	syncOnChange := flags.BoolP("sync", "s", true, "是否在每次添加、删除、修改时立即同步到词典文件")
	restartRimeCmd := flags.String("cmd", "", "同步到词典文件后，用于重新部署rime的命令，使更改即时生效，不同的系统环境下需要不同的命令")

	export := flags.StringP("export", "e", "", "导出码表到此文件，或使用特殊词'stdout'，将会把码表内容输出到标准输出流中。")
	exportColumns := flags.String("cols", "text,code,weight", "依赖-e参数，导出码表时，导出列(text:字词,code:编码,weight:权重)的顺序。")

	showVersion := flags.BoolP("version", "v", false, "显示版本号，在此检查最新版本 https://github.com/MapoMagpie/rimedm")

	flags.Usage = func() {
		fmt.Fprintln(os.Stderr, `rimedm: 维护码表的好帮手
  此程序提供一个Tui界面，当你输入时能实时搜索对应的项。
  按下确认键可选择将输入内容加入码表，或是在搜索结果中选择要修改、删除的项。
  注：1. 加词时输入的内容顺序随意，只要以空格隔开即可; 2. 不会破坏码表原本的样式，如注释、配置

选项：`)
		flags.PrintDefaults()
		fmt.Fprintln(os.Stderr, `
示例:
  1. 省心版，自动检测rime码表并在默认配置路径下生成配置：
     rimedm
  2. 导出码表
     rimedm -e 某某码表.txt
     rimedm -e 多多码表.txt --cols text,code
     rimedm -e stdout
  3. 指定多词典
     rimedm -d rime/xkjd.dict.yaml -d table/mb.txt(支持所有以制表符分隔字码的码表)
  4. 禁用修改后 "立即同步码表"、"执行重新部属命令" ，但仍在退出时执行。当你的系统文件性能低，每次加词改词会卡顿时用此方法。
     rimedm -s false
			`)
	}
	flags.CommandLine.SortFlags = false
	flags.Parse()
	if *showVersion {
		fmt.Println(version)
		os.Exit(0)
	}

	fixedConfigPath := fixPath(*configPath)
	opts := parseFromFile(fixedConfigPath)

	if len(*dictPaths) > 0 {
		opts.DictPaths = *dictPaths
		opts.UserPath = ""
	}
	if userPath != nil && *userPath != "" {
		opts.UserPath = *userPath
	}
	if restartRimeCmd != nil && *restartRimeCmd != "" {
		opts.RestartRimeCmd = *restartRimeCmd
	}
	if export != nil && *export != "" {
		opts.Export = *export
	}
	if exportColumns != nil && *exportColumns != "" {
		split := strings.SplitSeq(*exportColumns, ",")
		for sp := range split {
			switch strings.ToLower(sp) {
			case "text":
			case "code":
			case "weight":
			default:
				panic("参数--cols的有效值为text|code|weight，以逗号分隔")
			}
		}
		opts.ExportColumns = *exportColumns
	}
	if syncOnChange != nil && !*syncOnChange {
		opts.SyncOnChange = false
	}

	if len(opts.DictPaths) == 0 {
		panic(fmt.Sprintf("未指定词典文件，请检查配置文件[%s]或通过 -d 指定词典文件\n", fixedConfigPath))
	}

	for i := range opts.DictPaths {
		opts.DictPaths[i] = fixPath(opts.DictPaths[i])
	}
	opts.UserPath = fixPath(opts.UserPath)
	return opts, fixedConfigPath
}

func initConfigFile(filePath string) {
	dirPath := filepath.Dir(filePath)
	_, err := os.OpenFile(dirPath, os.O_RDONLY, 0666)
	if err != nil {
		if os.IsNotExist(err) {
			err = os.MkdirAll(dirPath, os.ModePerm)
			if err != nil {
				panic(fmt.Sprintf("mkdir [%s] err : %s", dirPath, err))
			}
		} else {
			panic(fmt.Sprintf("open [%s] err : %s", dirPath, err))
		}
	}
	file, err := os.Create(filePath)
	if err != nil {
		panic(fmt.Sprintf("create [%s] err : %s", filePath, err))
	}
	defer func() {
		_ = file.Close()
	}()
	_, err = file.WriteString(initConfigTemplate())
	if err != nil {
		panic(fmt.Sprintf("write [%s] err : %s", filePath, err))
	}
}

func initConfigTemplate() string {
	dicts, restartRimeCmd := osRimeDefaultValue()

	sb := strings.Builder{}
	dedup := make(map[string]bool, 0)
	for i, dict := range dicts {
		if _, ok := dedup[dict]; ok {
			continue
		}
		dedup[dict] = true
		if i > 0 {
			sb.WriteString("#")
		}
		sb.WriteString("  - ")
		sb.WriteString(dict)
		sb.WriteString("\n")
	}
	return fmt.Sprintf(`# Rime Dict Manager config file
# This file is generated by rime-dict-manager.

# 在此检查最新版本 https://github.com/MapoMagpie/rimedm

# dict_paths 是主词典文件的路径，本程序会自动加载主词典所引用的其他拓展词典。
# 支持多个主词典，注意是主词典，请不要将主词典与其所属拓展词典一同写在dict_paths:下
# 在Linux + Fcitx5 + Fcitx5-Rime下，词典的路径一般是: $HOME/.local/share/fcitx5/rime/方案名.dict.yaml
# 在Windows + 小狼毫下，词典的路径一般是: %%Appdata%%/Rime/方案名.dict.yaml
# dict_paths:
#   - 主词典1文件路径
#   - 主词典2文件路径
#   # 禁止
#   - 主词典1下的拓展词典文件路径

dict_paths:
%s

# 此项的作用是：优先作为添加新词时的选项，比如挂载的方案专门留了个给用户添加新词的码表
# 注意：需要此文件包含在主词典的拓展词典中。

# user_path: 

# 是否在每次添加、删除、修改时立即同步到词典文件，默认为 true
# 注意：由于Windows的文件性能不佳，部署小狼毫时不太流畅，可禁用此项
#       然后通过ctrl+s手动实时同步，或在本程序退出时自动同步。

sync_on_change: true 

# 在同步词典文件时，通过这个命令来重启 rime, 不同的系统环境下需要不同的命令。
# 在Linux + Fcitx5 下可通过此命令来重启 rime: 
#   dbus-send --session --print-reply --dest=org.fcitx.Fcitx5 /controller org.fcitx.Fcitx.Controller1.SetConfig string:'fcitx://config/addon/rime' variant:string:''
# 在Windows + 小狼毫 下可通过此命令来重启 rime(注意程序版本): 
#   C:\PROGRA~2\Rime\weasel-0.14.3\WeaselDeployer.exe /deploy
#   注:PROGRA~2 = Program Files (x86) PROGRA~1 = Program Files
# 在MacOS   + 鼠须管 下可通过此命令来重启 rime: 
#   /Library/Input Methods/Squirrel.app/Contents/MacOS/Squirrel --reload

restart_rime_cmd: %s`, sb.String(), restartRimeCmd)
}

func osRimeDefaultValue() (dicts []string, restartRimeCmd string) {
	configDir, err := os.UserConfigDir()
	if err != nil {
		return []string{}, ""
	}
	switch runtime.GOOS {
	case "windows":
		// find rime install path
		dirEntries, err := os.ReadDir("C:\\PROGRA~2\\Rime")
		var maxVersion string
		if err == nil && len(dirEntries) > 0 {
			for _, dir := range dirEntries {
				if dir.IsDir() && strings.HasPrefix(dir.Name(), "weasel") {
					dirName := dir.Name()
					if compareVersion(dirName, maxVersion) {
						maxVersion = dirName
					}
				} else {
					continue
				}
			}
		}
		dicts = findRimeDicts(filepath.Join(configDir, "rime"))
		if maxVersion != "" {
			restartRimeCmd = filepath.Join("C:\\PROGRA~2\\Rime", maxVersion, "WeaselDeployer.exe") + " /deploy"
		}
	case "dwain":
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return []string{}, ""
		}
		dicts = findRimeDicts(filepath.Join(homeDir, "Library", "Rime"))
		restartRimeCmd = "\"/Library/Input Methods/Squirrel.app/Contents/MacOS/Squirrel\" --reload" // mabye
	default:
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return []string{}, ""
		}
		dicts = findRimeDicts(filepath.Join(homeDir, ".local/share/fcitx5/rime"))
		restartRimeCmd = "dbus-send --session --print-reply --dest=org.fcitx.Fcitx5 /controller org.fcitx.Fcitx.Controller1.SetConfig string:'fcitx://config/addon/rime' variant:string:''"
	}
	return
}

func parseFromFile(path string) Options {
	path = fixPath(path)
	file, err := os.Open(path)
	if err != nil {
		if os.IsNotExist(err) {
			initConfigFile(path)
			file, err = os.Open(path)
			if err != nil {
				panic(fmt.Sprintf("init config file [%s] err : %s", path, err))
			}
		} else {
			panic(fmt.Sprintf("open [%s] err : %s", path, err))
		}
	}
	defer func() {
		_ = file.Close()
	}()
	stat, err := file.Stat()
	if err != nil {
		panic(fmt.Sprintf("file stat [%s] err : %s", path, err))
	}
	bs := make([]byte, stat.Size())
	_, _ = file.Read(bs)
	var opts Options
	err = yaml.Unmarshal(bs, &opts)
	if err != nil {
		panic(fmt.Sprintf("parse config [%s] err : %s", path, err))
	}
	return opts
}

func findRimeDicts(rimeConfigDir string) []string {
	defaults := []string{
		filepath.Join(rimeConfigDir, "default.yaml"),
		filepath.Join(rimeConfigDir, "default.custom.yaml"),
	}

	var file *os.File
	for _, de := range defaults {
		f, err := os.Open(fixPath(de))
		if err != nil {
			continue
		} else {
			file = f
			break
		}
	}
	defer func() {
		_ = file.Close()
	}()

	reader := bufio.NewReader(file)
	schemes := make([]string, 0)
	for {
		line, eof := reader.ReadString('\n')
		if eof != nil {
			break
		}
		hashTagIndex := strings.Index(line, "#")
		if i := strings.Index(line, "- schema:"); i != -1 {
			end := len(line)
			if hashTagIndex != -1 {
				if hashTagIndex < i {
					continue
				} else {
					end = hashTagIndex
				}
			}
			schema := strings.TrimSpace(line[i+len("- schema:") : end])
			schemes = append(schemes, schema+".schema.yaml")
		}
	}
	dicts := make([]string, 0)
	for _, schema := range schemes {
		schemaPath := fixPath(filepath.Join(rimeConfigDir, schema))
		schemaFile, err := os.Open(schemaPath)
		if err != nil {
			log.Println("cannot find schema: ", schemaPath)
			continue
		}
		defer func(ff *os.File) {
			_ = ff.Close()
		}(schemaFile)
		// find dict prefix from schemaFile
		schemaReader := bufio.NewReader(schemaFile)
		duringTranslator := false
		for {
			line, eof := schemaReader.ReadString('\n')
			if eof != nil {
				break
			}
			if i := strings.Index(line, "translator:"); i == 0 {
				duringTranslator = true
				continue
			}
			if duringTranslator {
				first := line[:1]
				if (first >= "0" && first <= "9") || (first >= "a" && first <= "z") || (first >= "A" && first <= "Z") {
					duringTranslator = false
					break
				}
				hashTagIndex := strings.Index(line, "#")
				if i := strings.Index(line, "dictionary: "); i != -1 {
					end := len(line)
					if hashTagIndex != -1 {
						if hashTagIndex < i {
							continue
						} else {
							end = hashTagIndex
						}
					}
					dictPrefix := strings.TrimSpace(line[i+len("dictionary: ") : end])
					dictPath := fixPath(filepath.Join(rimeConfigDir, dictPrefix+".dict.yaml"))
					if _, err := os.Stat(dictPath); errors.Is(err, os.ErrNotExist) {
						log.Println("cannot find dict: ", dictPath)
						continue
					} else {
						log.Println("find dict:", dictPath, "; schema:", schema)
					}
					// check dict file exist
					dicts = append(dicts, dictPath)
					break
				}
			}
		}
	}
	// dictPath = filepath.Join(configDir, "Rime", dicts+".dict.yaml")
	return dicts
}

func fixPath(path string) string {
	newPath := path
	if strings.HasPrefix(path, "~") {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			panic(err)
		}
		newPath = homeDir + (path)[1:]
	}
	return os.ExpandEnv(newPath)
}

func parseVersion(version string) []int {
	ret := make([]int, 0)
	reg := regexp.MustCompile(`\d+`)
	res := reg.FindAllString(version, -1)
	for _, v := range res {
		num, err := strconv.Atoi(v)
		if err != nil {
			fmt.Println("convert error", v)
		}
		ret = append(ret, num)
	}
	return ret
}

func compareVersion(v1, v2 string) bool {
	vi := parseVersion(v1)
	vj := parseVersion(v2)
	for k := 0; k < len(vi) && k < len(vj); k++ {
		if vi[k] != vj[k] {
			return vi[k] > vj[k]
		}
	}
	return v1 > v2
}
