package main

import (
	"flag"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/goccy/go-yaml"
	"log"
	"os"
	"path/filepath"
	"strings"
)

type Options struct {
	DictPath       string `yaml:"dict_path"`
	RestartRimeCmd string `yaml:"restart_rime_cmd"`
	UserPath       string `yaml:"user_path"`
	SyncOnChange   bool   `yaml:"sync_on_change"`
}

func initConfigFile(filePath string) {
	dirPath := filepath.Dir(filePath)
	// check dir is existed
	_, err := os.OpenFile(dirPath, os.O_RDONLY, 0666)
	if err != nil {
		if os.IsNotExist(err) {
			err = os.MkdirAll(dirPath, os.ModePerm)
			if err != nil {
				log.Fatalf("mkdir [%s] err : %s", dirPath, err)
			}
		} else {
			log.Fatalf("open [%s] err : %s", dirPath, err)
		}
	}
	file, err := os.Create(filePath)
	if err != nil {
		log.Fatalf("create [%s] err : %s", filePath, err)
	}
	defer func() {
		_ = file.Close()
	}()
	_, err = file.WriteString(configTemplate)
	if err != nil {
		log.Fatalf("write [%s] err : %s", filePath, err)
	}
}

func parseConfig(path string) *Options {
	path = fixPath(path)
	file, err := os.Open(path)
	if err != nil {
		if os.IsNotExist(err) {
			initConfigFile(path)
			file, err = os.Open(path)
			if err != nil {
				log.Fatalf("init config file [%s] err : %s", path, err)
			}
		} else {
			log.Fatalf("open [%s] err : %s", path, err)
		}
	}
	defer func() {
		_ = file.Close()
	}()
	stat, err := file.Stat()
	if err != nil {
		log.Fatalf("file stat [%s] err : %s", path, err)
	}
	bs := make([]byte, stat.Size())
	_, err = file.Read(bs)
	var opts Options
	err = yaml.Unmarshal(bs, &opts)
	if err != nil {
		log.Fatalf("parse config [%s] err : %s", path, err)
	}
	return &opts
}

var configTemplate = `# Rime Dict Manager config file
# This file is generated by rime-dict-manager.

# dict_path 是主词典文件的路径，本程序会自动加载主词典所引用的其他拓展词典。
# 在Linux + Fcitx5 + Fcitx5-Rime下，词典的路径一般是: $HOME/.local/share/fcitx5/rime/方案名.dict.yaml
# 在Windows + 小狼毫下，词典的路径一般是: %Appdata%/rime/方案名.dict.yaml
# 请务必取消注释并修改此处
dict_path:

# user_path 是用户词典路径，可以为空，
#	当指定了用户词典时，在添加新词时，用户词典会作为优先的添加选项。
#	如果没有指定用户词典，你也可以在添加时的选项中选择用户词典或其他词典。
user_path: 

# 是否在每次添加、删除、修改时立即同步到词典文件，默认为 true
sync_on_change: true 
# 在同步词典文件时，通过这个命令来重启 rime, 不同的系统环境下需要不同的命令。
# 在Linux + Fcitx5 下可通过此命令来重启 rime: 
#	dbus-send --session --print-reply --dest=org.fcitx.Fcitx5 /controller org.fcitx.Fcitx.Controller1.SetConfig string:'fcitx://config/addon/rime' variant:string:''
# 在Windows + 小狼毫 下可通过此命令来重启 rime(注意程序版本): 
#	C:\PROGRA~2\Rime\weasel-0.14.3\WeaselDeployer.exe /deploy
#	注:PROGRA~2 = Program Files (x86) PROGRA~1 = Program Files
restart_rime_cmd: `

var configPath string

func init() {
	configDir, err := os.UserConfigDir()
	if err != nil {
		panic(err)
	}
	configPath = filepath.Join(configDir, "rimedm", "config.yaml")
	var restartRimeCmd string
	if os.PathSeparator == '\\' { // windows
		restartRimeCmd = "C:\\PROGRA~2\\Rime\\weasel-0.14.3\\WeaselDeployer.exe /deploy"
	} else {
		restartRimeCmd = "dbus-send --session --print-reply --dest=org.fcitx.Fcitx5 /controller org.fcitx.Fcitx.Controller1.SetConfig string:'fcitx://config/addon/rime' variant:string:''"
	}
	configTemplate = configTemplate + restartRimeCmd
}

func main() {
	var optsFromFlag Options
	flag.StringVar(&optsFromFlag.DictPath, "d", "", "主词典文件路径，通过主词典也可以自动加载其他拓展词典")
	flag.StringVar(&optsFromFlag.UserPath, "u", "", "用户词典路径，可以为空")
	flag.StringVar(&optsFromFlag.RestartRimeCmd, "r", "", "同步词典时，重启 rime 的命令，不同的系统环境下需要不同的命令")
	flag.BoolVar(&optsFromFlag.SyncOnChange, "sc", true, "是否在每次添加、删除、修改时立即同步到词典文件，默认为 true")
	flag.StringVar(&configPath, "config", configPath, "配置文件路径")
	flag.Parse()

	configPath = fixPath(configPath)
	opts := parseConfig(configPath)

	if optsFromFlag.DictPath != "" {
		opts.DictPath = optsFromFlag.DictPath
	}
	if optsFromFlag.UserPath != "" {
		opts.UserPath = optsFromFlag.UserPath
	}
	if optsFromFlag.RestartRimeCmd != "" {
		opts.RestartRimeCmd = optsFromFlag.RestartRimeCmd
	}

	if !optsFromFlag.SyncOnChange {
		opts.SyncOnChange = false
	}
	if opts.DictPath == "" {
		log.Fatalf("未指定词典文件，请检查配置文件[%s]或通过 -d 指定词典文件", configPath)
	}

	opts.DictPath = fixPath(opts.DictPath)
	opts.UserPath = fixPath(opts.UserPath)
	f, err := tea.LogToFile(filepath.Dir(configPath)+"/debug.log", "DEBUG")
	if err != nil {
		log.Fatalf("log to file err : %s", err)
	}
	defer func() {
		_ = f.Close()
	}()
	Start(opts)
}

func fixPath(path string) string {
	if strings.HasPrefix(path, "~") {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			panic(err)
		}
		path = homeDir + path[1:]
	}
	return os.ExpandEnv(path)
}
